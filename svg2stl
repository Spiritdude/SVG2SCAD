#!/usr/bin/perl

# --- SVG 2 STL, written by Rene K. Mueller <spiritdude@gmail.com>
#
# License: GPLv2
#
# History:
# 2012/07/31: first rudimentary version

#use SVG;
use Math::Trig;
use XML::Simple;
use Math::Bezier;
use Data::Dumper;
#use Math::VectorReal;

$arg{verbose}++, shift(@ARGV) if($ARGV[0]eq'-v');
$type = shift(@ARGV) if(!-f $ARGV[0]);
$fin = shift(@ARGV);
#$arg{verbose}++;

convert($fin);

sub convert {
   my($f) = @_;
   my $xml = new XML::Simple;
   $svg = $xml->XMLin($f);
   print STDERR Dumper($svg) if($arg{verbose});
   my($w,$h) = ($svg->{width},$svg->{height});
   #print STDERR "size: $w x $h\n";
   
   my(@o);
   
   if(0&&ref($svg->{g}->{path}) eq 'HASH') {
      push(@no,keys $svg->{g}->{path});
      print STDERR "multiple (",($#no+1),": @no) graphs\n";
      @o = decodePath($svg->{g}->{path}->{$no[0]}->{d});
      @p = decodePath($svg->{g}->{path}->{$no[1]}->{d});
      
   } else {
      @o = decodePath($svg->{g}->{path}->{d});
   }
   #my(@r) = getMinMax(@o);
   # -- normalize (x = 0 ... $w, y = 0 .. $h)

   for(my $i=0; $i<=$#o; $i+=2) {
      $o[$i] -= $minx;
      $o[$i+1] -= $miny;
   }
   $w = $maxx-$minx;
   $h = $maxy-$miny;

   $method = 'rotate'; 

   # --- see http://www.ennex.com/~fabbers/StL.asp

   print "solid svg2stl\n";
   if($method eq 'rotate') {
      my $sides = 32;
      while($#o>=3) {
         my($x1,$y1,$x2,$y2) = @o[0..3];
         $y1 = -$y1;
         $y2 = -$y2;
         for(my $n = 0; $n < $sides; $n++) {
            my $r1 = $x1;
            my $r2 = $x2;

            #  p1    p2
            #  y1,n  y1,n+1   r1
            #
            #  p4    p3
            #  y2,n  y2,n+1   r2
            
            my $x1p = $r1*sin($n/$sides*pi*2), $y1p = $r1*cos($n/$sides*pi*2);
            my $x2p = $r1*sin(($n+1)/$sides*pi*2), $y2p = $r1*cos(($n+1)/$sides*pi*2);
            my $x3p = $r2*sin(($n+1)/$sides*pi*2), $y3p = $r2*cos(($n+1)/$sides*pi*2);
            my $x4p = $r2*sin($n/$sides*pi*2), $y4p = $r2*cos($n/$sides*pi*2);

            f3v($x1p,$y1p,$y1, $x2p,$y2p,$y1, $x3p,$y3p,$y2);     # --- 1,2,3 (cw)
            f3v($x1p,$y1p,$y1, $x3p,$y3p,$y2, $x4p,$y4p,$y2);     # --- 1,3,4 (cw)
            #f3v($x1p,$y1p,$y1, $x3p,$y3p,$y2, $x2p,$y2p,$y1);     # --- 1,3,2 (ccw)
            #f3v($x1p,$y1p,$y1, $x4p,$y4p,$y2, $x3p,$y3p,$y2);     # --- 1,4,3 (ccw)
         }
         splice(@o,0,2);
      }
      print "endsolid svg2stl\n"; 
      
   } else {
      print "unknown method <$method>\n";
   }
}

sub decodePath {
   # -- reference: http://apike.ca/prog_svg_paths.html
   # ---- example: "m -205.71429,23.790754 c 0,0 225.71429,11.428571 305.71429,154.285716 52.47585,93.70687 25.71428,202.85714 25.71428,202.85714 L 62.857143,478.07647 60,386.6479 l -51.4285714,0 -2.8571429,311.42856 -57.1428577,2.85715 c 0,0 14.285715,-431.42857 -22.857142,-511.42857 -37.142856,-80 -131.428576,37.14286 -131.428576,37.14286";
   my($d) = @_;
   my(@s) = split /[,\s]+/, $d;
   my($xp,$yp) = (0,0);
   my($lc);
   my(@o);
   
   $minx = 1e38, $miny = 1e38;
   $maxx = -1e38, $maxy = -1e38;
   
   while($#s>=0) {
      print STDERR "current pos: $xp,$yp\n" if($arg{verbose}>1);
      if($s[0]=~/^[a-z]/i) {
         $c = shift(@s);
         print STDERR "command <$c>\n" if($arg{verbose}>1);
      } else {
         $c = $lc;
         print STDERR "command <$c> again\n" if($arg{verbose}>1);
      }
      if($c eq 'm'||$c eq 'M') {
         # -- moveto
         my($x,$y) = getArgs(\@s,2);
         $xp += $x, $yp += $y if($c eq 'm');
         $xp = $x, $yp = $y if($c eq 'M');
         pushPoint(\@o,$xp,$yp);
         
      } elsif($c eq 'l'||$c eq 'L') {
         # -- lineto
         my($x,$y) = getArgs(\@s,2);
         $xp += $x, $yp += $y if($c eq 'l');
         $xp = $x, $yp = $y if($c eq 'L');
         pushPoint(\@o,$xp,$yp);
          
      } elsif($c eq 'c'||$c eq 'C') {
         # -- curveto 
         my($steps) = 32;
         my($x1,$y1,$x2,$y2,$x,$y) = getArgs(\@s,6);
         if($c eq 'c') {
            $x1 += $xp; $y1 += $yp;
            $x2 += $xp; $y2 += $yp;
            $x += $xp; $y += $yp;
         }
         # -- see http://search.cpan.org/~abw/Math-Bezier-0.01/Bezier.pm
         my $b = Math::Bezier->new($xp,$yp,$x1,$y1,$x2,$y2,$x,$y);
         my($_x,$_y);

         for(my $i = 0; $i <= $steps; $i++) {
            my $r = $i/$steps;
            ($_x,$_y) = $b->point($r);
            print STDERR "\t$_x,$_y ($r)\n" if($arg{verbose}>1);
            pushPoint(\@o,$_x,$_y);
         }
         $xp = $_x; $yp = $_y;
      
      } elsif($c eq 'h'||$c eq 'H') {
         # -- hlineto
         my($x) = getArgs(\@s,1);
         pushPoint(\@o,$xp,$yp);
         $xp += $x if($c eq 'h');
         $xp = $x if($c eq 'H');
         pushPoint(\@o,$xp,$yp);
         
      } elsif($c eq 'v'||$c eq 'V') {
         # -- vlineto
         my($y) = getArgs(\@s,1);
         pushPoint(\@o,$xp,$yp);
         $yp += $y if($c eq 'v');
         $yp = $y if($c eq 'V');
         pushPoint(\@o,$xp,$yp);
         
      #} elsif($c eq 'q') {
      #   my($x1,$y1,$x,$y) = getArgs(\@s,4);
      #} elsif($c eq 's') {
      #   my($x2,$y2,$x,$y) = getArgs(\@s,4);
      #} elsif($c eq 't') {
      #   my($x,$y) = getArgs(\@s,2);
      #} elsif($c eq 'a') {
      #   my($rx,$ry,$xa,$laf,$sf,$x,$y) = getArgs(\@s,7);
      } elsif($c eq 'z'||$c eq 'Z') {
         ;
      } else {
         print STDERR "<$c> is not a command\n";
         last;
      }
      $lc = $c;
   }
   print STDERR "total ",(($#o+1)/2)," points";
   return @o;
}

sub pushPoint {
   my($o,$x,$y) = @_;
   $minx = $x if($minx>$x);
   $miny = $y if($miny>$y);
   $maxx = $x if($maxx<$x);
   $maxy = $y if($maxy<$y);
   push($o,$x,$y);
}

sub getArgs {
   my($a,$n) = @_;
   $n = 1 unless($n);
   @_ = splice($a,0,$n);
   print STDERR "\targs = ".join(',',@_),"\n" if($arg{verbose});
   return @_;
}

sub f3v {
   my(@c) = @_;
   #print "facet normal 1 0 0\n";
   my(@n);

   # -- p1-p0
   @n[0] = $c[0+3*1]-$c[0+3*0];
   @n[1] = $c[1+3*1]-$c[1+3*0];
   @n[2] = $c[2+3*1]-$c[2+3*0];

   # -- p2-p0
   @n[3] = $c[0+3*2]-$c[0+3*0];
   @n[4] = $c[1+3*2]-$c[1+3*0];
   @n[5] = $c[2+3*2]-$c[2+3*0];

   # -- (r0 x r1) see http://freespace.virgin.net/hugo.elias/routines/r_cross.htm
   @n[6] = $n[1+3*0]*$n[2+3*1] - $n[1+3*1]*$n[2+3*0];
   @n[7] = $n[2+3*0]*$n[0+3*1] - $n[2+3*1]*$n[0+3*0];
   @n[8] = $n[0+3*0]*$n[1+3*1] - $n[0+3*1]*$n[1+3*0];

   print STDERR "\tvertices(3x3) = ",join(', ',@c[0..8]),"\n" if($arg{verbose}>1);
   print STDERR "\tnormal (not normalized) = ",join(', ',@n[6..8]),"\n" if($arg{verbose}>1);

   my $l = sqrt($n[6]*$n[6] + $n[7]*$n[7] + $n[8]*$n[8]);

   if($l) {
      @_ = map { $_ /= $l } @n[6..8];
      print STDERR "\tnormal (normalized) = ",join(', ',@_[0..3]),"\n" if($arg{verbose}>1);
   
      print "facet normal ",join(" ",@_),"\n";
      print "outer loop\n";
      for(0..2) {
         print "vertex ",join(' ',map { $_ } splice(@c,0,3)),"\n";
      }
      print "endloop\nendfacet\n";
      
   } else {
      #print STDERR "WARNING: face dropped, normal was 0,0,0\n";
      return 0;
   }
   return 1;
}
